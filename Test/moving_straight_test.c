#pragma config(Sensor, in1,    light_sensor,   sensorReflection)
#pragma config(Sensor, in2,    line_follower_left, sensorLineFollower)
#pragma config(Sensor, in3,    line_follower_middle, sensorLineFollower)
#pragma config(Sensor, in4,    line_follower_right, sensorLineFollower)
#pragma config(Sensor, in5,    arm_potentiometer, sensorPotentiometer)
#pragma config(Sensor, dgtl5,  quadrature_left, sensorQuadEncoder)
#pragma config(Sensor, dgtl7,  quadrature_right, sensorQuadEncoder)
#pragma config(Sensor, dgtl9,  safety_switch,  sensorTouch)
#pragma config(Sensor, dgtl10, sonar,          sensorSONAR_cm)
#pragma config(Sensor, dgtl12, front_button,   sensorTouch)
#pragma config(Motor,  port1,           left_motor,    tmotorVex269, openLoop, reversed, encoder, encoderPort, dgtl5, 1000)
#pragma config(Motor,  port6,           claw_motor,    tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port7,           arm_motor,     tmotorServoContinuousRotation, openLoop, reversed)
#pragma config(Motor,  port10,          right_motor,   tmotorVex269, openLoop, encoder, encoderPort, dgtl7, 1000)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*----------------------------------------------------------------------------------------------------*\
|*                                 - Moving Straight with Encoders -                                  *|
|*                                      ROBOTC on VEX 2.0 CORTEX                                      *|
|*                                                                                                    *|
|*  This program implements a self-straightening algorithm that provides a higher power level to the  *|
|*  motor that has traveled less, determined by comparing the values of the two encoders.             *|
|*  There is a 2 second pause at the beginning of the program.                                        *|
|*                                                                                                    *|
|*                                        ROBOT CONFIGURATION                                         *|
|*    NOTES:                                                                                          *|
|*    1)  Reversing 'right_motor' (port 2) in the "Motors and Sensors Setup" is needed with the        *|
|*        "Squarebot" model, but may not be needed for all robot configurations.                      *|
|*    2)  Whichever encoder is being used for feedback should be cleared just before it starts        *|
|*        counting by using the "SensorValue(encoder) = 0;".  This helps ensure consistancy.          *|
|*                                                                                                    *|
|*    MOTORS & SENSORS:                                                                               *|
|*    [I/O Port]          [Name]              [Type]                [Description]                     *|
|*    Motor   - Port 2    right_motor          VEX 3-wire module     Right side motor                  *|
|*    Motor   - Port 3    left_motor           VEX 3-wire module     Left side motor                   *|
|*    Digital - Port 1,2  quadrature_right        VEX Shaft Encoder     Right side                        *|
|*    Digital - Port 3,4  quadrature_left         VEX Shaft Encoder     Left side                         *|
\*----------------------------------------------------------------------------------------------------*/

//<><><><><><><><><><><><><><><><><><><><><><><| Fall |><><><><><><><><><><><><><><><><><><><><><><><>
/*
#include <../includes/common_headers/stdio.h>
#include <../includes/common_headers/stdlib.h>
#include <../includes/common_headers/stdarg.h>
#include <../includes/common_headers/string.h>


void print (char * str, ...)
{
	va_list vl;
	int i = 0, j=0;
	char buff[100]={0}, tmp[20];
	va_start( vl, str );

	while (str && str[i]){
		if(str[i] == '%'){
			i++;
			switch (str[i]) {
				case 'c': {
					buff[j] = (char)va_arg( vl, int );
					j++;
					break;
				}
				case 'd': {
					itoa(va_arg( vl, int ), tmp, 10);
					strcpy(&buff[j], tmp);
					j += strlen(tmp);
					break;
				}
				case 'x': {
					itoa(va_arg( vl, int ), tmp, 16);
					strcpy(&buff[j], tmp);
					j += strlen(tmp);
					break;
				}
			}
		} else {
			buff[j] =str[i];
			j++;
		}
		i++;
	}
	fwrite(buff, j, 1, stdout);
	va_end(vl);
	// return j;
}
*/



//<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>



//+++++++++++++++++++++++++++++++++++++++++++++| MAIN |+++++++++++++++++++++++++++++++++++++++++++++++
task main()
{
	SensorValue[quadrature_right] = 0;	  // Set the encoder so that it starts counting at 0
	SensorValue[quadrature_left]  = 0;	  // Set the encoder so that it starts counting at 0

	while(1 == 1)		// Creates an infinite loop, since "true" always evaluates to true
	{
		int motor_right_value = abs(SensorValue[quadrature_right]);
		int motor_left_value = abs(SensorValue[quadrature_left]);

		char motor_right_value_string[5];
		char motor_left_value_string[5];
		sprintf(motor_right_value_string, "%d", motor_right_value);
		sprintf(motor_left_value_string, "%d", motor_left_value);
		writeDebugStream("\n");
		writeDebugStream(motor_right_value_string);
		writeDebugStream(" - ");
		writeDebugStream(motor_left_value_string);


		if(motor_right_value == motor_left_value) // If quadrature_right has counted the same amount as quadrature_left:
		{
			// Move Forward
			motor[right_motor] = 100;		    // Right Motor is run at power level 80
			motor[left_motor]  = 127;		    // Left Motor is run at power level 80
		}
		else if(motor_right_value > motor_left_value)	// If quadrature_right has counted more encoder counts
		{
			// Turn slightly right
			motor[right_motor] = 74;		    // Right Motor is run at power level 60
			motor[left_motor]  = 127;		    // Left Motor is run at power level 80
		}
		else	// Only runs if quadrature_left has counted more encoder counts
		{
			// Turn slightly left
			motor[right_motor] = 127;		    // Right Motor is run at power level 80
			motor[left_motor]  = 127;		    // Left Motor is run at power level 60
		}
	}

}
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
